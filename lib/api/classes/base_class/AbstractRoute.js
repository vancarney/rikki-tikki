// Generated by CoffeeScript 1.7.1
var AbstractRoute, CollectionManager, RikkiTikkiAPI, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

_ = require('underscore')._;

RikkiTikkiAPI = module.parent.exports.RikkiTikkiAPI;

CollectionManager = {};

AbstractRoute = (function(_super) {
  __extends(AbstractRoute, _super);

  AbstractRoute.prototype.__before = null;

  AbstractRoute.prototype.__after = null;

  AbstractRoute.prototype.addBeforeHandler = function(fn) {
    if (typeof fn !== 'function') {
      throw "Param must be of type 'function' param was Type <" + (typeof fn) + ">";
    }
    if (this.__before == null) {
      this.__before = [];
    }
    return this.__before.push(fn);
  };

  AbstractRoute.prototype.addAfterHandler = function(fn) {
    if (typeof fn !== 'function') {
      throw "Param must be of type 'function' param was Type <" + (typeof fn) + ">";
    }
    if (this.__after == null) {
      this.__after = [];
    }
    return this.__after.push(fn);
  };

  function AbstractRoute(callback) {
    if ((RikkiTikkiAPI.Util.Function.getFunctionName(arguments.callee.caller.__super__.constructor)) !== 'AbstractRoute') {
      throw "AbstractRoute can not be directly instatiated. Use a subclass instead.";
    }
    this.__db = RikkiTikkiAPI.getConnection();
    this.__collections = RikkiTikkiAPI.getCollectionManager();
    return (function(_this) {
      return function(req, res) {
        return _this.handler(callback)(req, res);
      };
    })(this);
  }

  AbstractRoute.prototype.handler = function(req, res) {
    throw "" + (RikkiTikkiAPI.Util.Function.getConstructorName(this)) + ".hassh(req,res) is not implemented";
  };

  AbstractRoute.prototype.sanitize = function(query) {
    var filter, filtered, restricted;
    filter = null;
    filtered = [];
    restricted = [];
    filter = _.partial(_.without, _.keys(query));
    _.each(RikkiTikkiAPI.OperationTypes.query, (function(_this) {
      return function(v) {
        return filtered = filter(v);
      };
    })(this));
    _.each(filtered, (function(_this) {
      return function(v, k) {
        if (v.match(/^\$/)) {
          delete query[v];
        }
        if (restricted.indexOf(v >= 0)) {
          return delete query[v];
        }
      };
    })(this));
    return query;
  };

  AbstractRoute.prototype.createCollection = function(name, callback) {
    if (AbstractRoute.isDevelopment() && !AbstractRoute.collectionExists(name)) {
      console.log("creating collection " + name);
      return this.__collections.createCollection(name, {}, (function(_this) {
        return function(e, res) {
          return RikkiTikkiAPI.getSchemaManager().createSchema(name, {}, function(e, res) {
            return RikkiTikkiAPI.getSchemaTreeManager().createTree(name, {}, function(e, res) {
              return typeof callback === "function" ? callback(e, res) : void 0;
            });
          });
        };
      })(this));
    }
  };

  AbstractRoute.prototype.checkSchema = function(name) {};

  return AbstractRoute;

})(Object);

AbstractRoute.isDevelopment = function() {
  return RikkiTikkiAPI.Util.Env.isDevelopment();
};

AbstractRoute.collectionExists = function(name) {
  return 0 <= RikkiTikkiAPI.listCollections().indexOf(name);
};

module.exports = AbstractRoute;


/*
    if obj.before
      path = "#{@__api_path}/:collection/:id"
      app.all path, obj.before
      verbose && logger?.log 'debug', "     ALL #{path} -> before" 
      path = "#{@__api_path}/:collection/:id/*"
      app.all path, obj.before
      verbose && logger?.log 'debug', "     ALL #{path} -> before" 

    if obj.after
      path = "#{@__api_path}/:collection/:id"
      app.all path, obj.after
      verbose && logger?.log 'debug', "     ALL #{path} -> after" 
      path = "#{@__api_path}/:collection/:id/*"
      app.all path, obj.after
      verbose && logger?.log 'debug', "     ALL #{path} -> after"
 */
